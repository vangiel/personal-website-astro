---
title: "Chatbot tutorial (Part 2) - Coding the backend"
pubDate: "Jul 5 2024"
heroImage: "@/images/blog/Tutorials/1_Chatbot/frontmatter.png"
imageAlt: "Frontmatter of the page which consists of an AI generated image of a chatbot."
tags: ["Tutorials", "Web Development", "AI"]
slug: "tutorials/chatbot-part2"
---

In this part we will create a new API route in AstroJS to handle the requests from the client.
The queries to the AI model will be done in the server, and we need a endpoint to get the data from the client.
In this case we will create just one API route but with two HTTP methods, a POST to send the message from the user to the server so we can query the model and a GET to stream the response from the model using SSE (sever side events).

We create a new file in the `src/pages/api/` directory named `chatbot.ts`. The first thing is to create tow global variables to store the messages and the config and that both exposed enpoints can share information.

```typescript
// src/pages/api/chatbot.ts
let messagesFromUser: RoleScopedChatInput[] = [];
let config: ChatbotConfig = {
	model: "@cf/meta/llama-3-8b-instruct-awq", // Default model
};
```

```typescript
// src/pages/api/chatbot.ts

import type { APIContext } from "astro";
export async function POST({ request }: APIContext) {
	messagesFromUser = [{ role: "system", content: "You are a friendly assistant" }];
	const payloads = (await request.json()) as ChatbotPayload[];

	messagesFromUser = messagesFromUser.concat(payloads.map((p) => p.message));
	config = payloads[0].config || config;

	return new Response(null, { status: 204 });
}
```

```typescript
// src/pages/api/chatbot.ts
export async function GET({ locals }: APIContext) {
	const { AI } = locals.runtime.env;
	const messages = messagesFromUser;

	const stream = (await AI.run(config.model, {
		stream: true,
		messages,
	})) as ReadableStream<Uint8Array>;

	return new Response(stream, {
		headers: { "content-type": "text/event-stream" },
	});
}
```
